from typing import List, Dict, Any, Optional, Literal
import json
import yaml
from pathlib import Path
from loguru import logger
from src_v2.core.database import db_manager
from src_v2.agents.llm_factory import create_llm
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser


# Goal source hierarchy: Core > User > Inferred > Strategic
GOAL_SOURCE_PRIORITY = {
    "core": 100,      # From goals.yaml - character's fundamental drives
    "user": 80,       # Explicitly requested by user
    "inferred": 60,   # Detected from conversation patterns
    "strategic": 40,  # Generated by GoalStrategist
}


class GoalManager:
    def __init__(self):
        self.default_goals = self._load_default_goals()
        self._character_goals_cache = {}
    
    def _load_default_goals(self) -> List[Dict[str, Any]]:
        """
        Load default goals that apply to all characters.
        """
        return [
            {
                "slug": "learn_name",
                "description": "Learn the user's name",
                "success_criteria": "User explicitly states their name",
                "priority": 10,
                "category": "personal_knowledge",
                "source": "core",
            }
        ]
    
    def _get_character_goals_file(self, character_name: str) -> Optional[Path]:
        """
        Get the path to a character's goals.yaml file.
        """
        goals_file = Path(f"characters/{character_name}/goals.yaml")
        if goals_file.exists():
            return goals_file
        return None
    
    def _load_character_goals_from_file(self, character_name: str) -> List[Dict[str, Any]]:
        """
        Load goals from a character's goals.yaml file.
        Returns the goals list or default goals if file doesn't exist.
        """
        if character_name in self._character_goals_cache:
            return self._character_goals_cache[character_name]
        
        goals_file = self._get_character_goals_file(character_name)
        
        if not goals_file:
            logger.debug(f"No goals.yaml found for {character_name}, using defaults")
            self._character_goals_cache[character_name] = self.default_goals
            return self.default_goals
        
        try:
            with open(goals_file, 'r') as f:
                data = yaml.safe_load(f)
                if data and 'goals' in data:
                    goals = data['goals']
                    logger.info(f"Loaded {len(goals)} goals for {character_name} from {goals_file}")
                    self._character_goals_cache[character_name] = goals
                    return goals
                else:
                    logger.warning(f"Invalid goals.yaml format for {character_name}")
                    return self.default_goals
        except Exception as e:
            logger.error(f"Failed to load goals for {character_name}: {e}")
            return self.default_goals

    async def ensure_goals_exist(self, character_name: str):
        """
        Ensures goals exist in the database for the character.
        Loads from character's goals.yaml file or uses defaults.
        """
        if not db_manager.postgres_pool:
            return

        # Load character-specific goals
        goals = self._load_character_goals_from_file(character_name)
        
        async with db_manager.postgres_pool.acquire() as conn:
            for goal in goals:
                # Check if goal exists
                exists = await conn.fetchval("""
                    SELECT id FROM v2_goals 
                    WHERE character_name = $1 AND slug = $2
                """, character_name, goal["slug"])
                
                if not exists:
                    source = goal.get("source", "core")
                    category = goal.get("category", "general")
                    await conn.execute("""
                        INSERT INTO v2_goals (character_name, slug, description, success_criteria, priority, source, category)
                        VALUES ($1, $2, $3, $4, $5, $6, $7)
                    """, character_name, goal["slug"], goal["description"], goal["success_criteria"], goal["priority"], source, category)
                    logger.info(f"Created goal '{goal['slug']}' for {character_name}")

    async def get_active_goals(self, user_id: str, character_name: str) -> List[Dict[str, Any]]:
        """
        Retrieves active (not completed, not expired) goals for the user.
        Ordered by source hierarchy (core > user > inferred > strategic), then by priority.
        User-specific goals (target_user_id) only shown to that user.
        """
        if not db_manager.postgres_pool:
            return []

        # First ensure goals exist
        await self.ensure_goals_exist(character_name)

        async with db_manager.postgres_pool.acquire() as conn:
            # Get goals that are NOT completed for this user
            # - Filter out expired goals
            # - User-specific goals only shown to their target user
            # - Order by source hierarchy, then priority
            query = """
                SELECT g.id, g.slug, g.description, g.success_criteria, g.priority,
                       g.source, g.category, g.current_strategy,
                       COALESCE(p.status, 'not_started') as status,
                       COALESCE(p.progress_score, 0.0) as progress
                FROM v2_goals g
                LEFT JOIN v2_user_goal_progress p ON g.id = p.goal_id AND p.user_id = $1
                WHERE g.character_name = $2
                AND (p.status IS NULL OR p.status != 'completed')
                AND (g.expires_at IS NULL OR g.expires_at > NOW())
                AND (g.target_user_id IS NULL OR g.target_user_id = $1)
                ORDER BY 
                    CASE g.source 
                        WHEN 'core' THEN 100
                        WHEN 'user' THEN 80
                        WHEN 'inferred' THEN 60
                        WHEN 'strategic' THEN 40
                        ELSE 0
                    END DESC,
                    g.priority DESC
            """
            rows = await conn.fetch(query, user_id, character_name)
            return [dict(row) for row in rows]
    
    async def get_goal_with_strategy(self, user_id: str, character_name: str) -> Optional[Dict[str, Any]]:
        """
        Returns the highest-priority active goal with its current strategy.
        Used for injecting into the system prompt as an "internal desire".
        """
        goals = await self.get_active_goals(user_id, character_name)
        if not goals:
            return None
        
        # Return the top-priority goal
        top_goal = goals[0]
        return {
            "description": top_goal["description"],
            "strategy": top_goal.get("current_strategy"),
            "source": top_goal.get("source", "core"),
        }
    
    async def update_goal_strategy(self, character_name: str, goal_slug: str, strategy: str):
        """
        Updates the current_strategy for a goal.
        Called by GoalStrategist worker.
        """
        if not db_manager.postgres_pool:
            return
        
        async with db_manager.postgres_pool.acquire() as conn:
            await conn.execute("""
                UPDATE v2_goals 
                SET current_strategy = $1
                WHERE character_name = $2 AND slug = $3
            """, strategy, character_name, goal_slug)
            logger.info(f"Updated strategy for goal '{goal_slug}': {strategy[:50]}...")

    async def update_goal_progress(self, user_id: str, goal_slug: str, character_name: str, status: str, progress: float = 0.0, metadata: Optional[Dict] = None):
        """
        Updates the progress of a specific goal.
        """
        if not db_manager.postgres_pool:
            return

        async with db_manager.postgres_pool.acquire() as conn:
            # Get goal ID
            goal_id = await conn.fetchval("""
                SELECT id FROM v2_goals WHERE character_name = $1 AND slug = $2
            """, character_name, goal_slug)
            
            if not goal_id:
                logger.warning(f"Goal '{goal_slug}' not found for {character_name}")
                return

            # Upsert progress
            await conn.execute("""
                INSERT INTO v2_user_goal_progress (user_id, goal_id, status, progress_score, metadata, updated_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
                ON CONFLICT (user_id, goal_id) 
                DO UPDATE SET 
                    status = EXCLUDED.status,
                    progress_score = EXCLUDED.progress_score,
                    metadata = COALESCE(v2_user_goal_progress.metadata, '{}'::jsonb) || EXCLUDED.metadata,
                    updated_at = NOW()
            """, user_id, goal_id, status, progress, json.dumps(metadata or {}))
            
            logger.info(f"Updated goal '{goal_slug}' for user {user_id}: {status} ({progress*100}%)")

class GoalAnalyzer:
    # Max goals to analyze in a single LLM call (prevents timeout with local models)
    MAX_GOALS_PER_BATCH = 3
    # Max conversation length to send (tokens are ~4 chars)
    MAX_CONVERSATION_CHARS = 2000
    # Per-batch timeout (seconds) - fail fast, don't wait for arq to kill us
    BATCH_TIMEOUT = 90
    # Retry settings
    MAX_RETRIES = 2
    RETRY_DELAY_BASE = 2  # seconds, doubles each retry
    
    def __init__(self):
        # Use utility LLM for goal analysis (evaluation task)
        self.llm = create_llm(temperature=0.0, mode="utility")
        self.parser = JsonOutputParser()
        
        # Simplified prompt for faster inference
        self.prompt = ChatPromptTemplate.from_template("""Evaluate if this conversation advanced these goals. Be concise.

GOALS:
{goals_context}

CONVERSATION:
{conversation_text}

Return JSON:
{{"updates": [{{"slug": "goal-slug", "status": "completed|in_progress|no_change", "progress_score": 0.0-1.0, "reasoning": "brief reason"}}]}}""")
        
        self.chain = self.prompt | self.llm | self.parser

    async def _process_batch_with_retry(
        self, 
        batch: List[Dict], 
        truncated_text: str, 
        batch_num: int
    ) -> List[Dict]:
        """Process a single batch with retry logic and timeout."""
        import asyncio
        
        goals_context = "\n".join(
            f"- {g['slug']}: {g['description']} (Criteria: {g['success_criteria']})"
            for g in batch
        )
        
        last_error = None
        for attempt in range(self.MAX_RETRIES + 1):
            try:
                # Wrap LLM call in timeout
                result = await asyncio.wait_for(
                    self.chain.ainvoke({
                        "goals_context": goals_context,
                        "conversation_text": truncated_text
                    }),
                    timeout=self.BATCH_TIMEOUT
                )
                return result.get("updates", [])
                
            except asyncio.TimeoutError:
                last_error = f"Timeout after {self.BATCH_TIMEOUT}s"
                logger.warning(f"Goal batch {batch_num} attempt {attempt + 1} timed out")
            except Exception as e:
                last_error = str(e)
                logger.warning(f"Goal batch {batch_num} attempt {attempt + 1} failed: {e}")
            
            # Exponential backoff before retry
            if attempt < self.MAX_RETRIES:
                delay = self.RETRY_DELAY_BASE * (2 ** attempt)
                await asyncio.sleep(delay)
        
        # All retries exhausted
        logger.error(f"Goal batch {batch_num} failed after {self.MAX_RETRIES + 1} attempts: {last_error}")
        return []

    async def check_goals(self, user_id: str, character_name: str, conversation_text: str) -> Dict[str, Any]:
        """
        Checks active goals against the recent conversation.
        Batches goals with retry logic.
        
        - Local LLMs (lmstudio, ollama): Sequential processing (single GPU)
        - Cloud LLMs (openai, openrouter): Parallel processing
        
        Returns:
            Dict with processing stats (for observability)
        """
        import asyncio
        from src_v2.config.settings import settings
        
        # Detect if we're using a local single-threaded LLM
        # Router LLM is used for utility tasks
        provider = settings.ROUTER_LLM_PROVIDER or settings.LLM_PROVIDER
        is_local = provider in ["lmstudio", "ollama"]
        
        stats = {
            "total_goals": 0,
            "batches_processed": 0,
            "batches_failed": 0,
            "goals_updated": 0,
            "mode": "sequential" if is_local else "parallel",
        }
        
        try:
            # 1. Get active goals
            active_goals = await goal_manager.get_active_goals(user_id, character_name)
            if not active_goals:
                return stats
            
            stats["total_goals"] = len(active_goals)
            
            # Truncate conversation to avoid massive prompts
            truncated_text = conversation_text[:self.MAX_CONVERSATION_CHARS]
            if len(conversation_text) > self.MAX_CONVERSATION_CHARS:
                truncated_text += "...[truncated]"

            # 2. Create batches
            batches = [
                active_goals[i:i + self.MAX_GOALS_PER_BATCH]
                for i in range(0, len(active_goals), self.MAX_GOALS_PER_BATCH)
            ]
            
            # 3. Process batches - sequential for local LLMs, parallel for cloud
            if is_local:
                # Sequential: one batch at a time (single GPU)
                batch_results = []
                for i, batch in enumerate(batches):
                    result = await self._process_batch_with_retry(batch, truncated_text, i + 1)
                    batch_results.append(result)
            else:
                # Parallel: all batches at once (cloud APIs handle concurrency)
                tasks = [
                    self._process_batch_with_retry(batch, truncated_text, i + 1)
                    for i, batch in enumerate(batches)
                ]
                batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 4. Process results and update goals
            for i, result in enumerate(batch_results):
                if isinstance(result, Exception):
                    stats["batches_failed"] += 1
                    logger.error(f"Batch {i + 1} raised exception: {result}")
                    continue
                
                stats["batches_processed"] += 1
                
                for update in result:
                    status = update.get("status")
                    if status in ["completed", "in_progress"]:
                        try:
                            await goal_manager.update_goal_progress(
                                user_id=user_id,
                                goal_slug=update.get("slug", "unknown"),
                                character_name=character_name,
                                status=status,
                                progress=update.get("progress_score", 0.0),
                                metadata={
                                    "reasoning": update.get("reasoning"), 
                                    "extracted": update.get("extracted_data")
                                }
                            )
                            stats["goals_updated"] += 1
                        except Exception as e:
                            logger.error(f"Failed to update goal {update.get('slug')}: {e}")
            
            logger.info(
                f"Goal analysis complete ({stats['mode']}): {stats['total_goals']} goals, "
                f"{stats['batches_processed']}/{len(batches)} batches OK, "
                f"{stats['goals_updated']} updated"
            )
            return stats
                    
        except Exception as e:
            logger.error(f"Goal analysis failed: {e}")
            return stats

goal_manager = GoalManager()
goal_analyzer = GoalAnalyzer()

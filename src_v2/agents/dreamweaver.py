"""DreamWeaver Agent - Specialized agent for narrative generation (dreams & diaries).

Unlike the real-time ReflectiveAgent, this agent runs in batch mode during
scheduled cron jobs and can take extended steps to:
1. PLAN the narrative arc (story structure, emotional journey)
2. GATHER correlated data across multiple sources
3. WEAVE a rich, multi-layered narrative

This enables dreams and diaries to have proper story arcs and emotional depth
that would be too slow for real-time response generation.
"""
import time
from typing import List, Dict, Any, Optional, Tuple
from loguru import logger
from langsmith import traceable

from langchain_core.messages import (
    BaseMessage,
    SystemMessage,
    HumanMessage,
    ToolMessage
)
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field

from src_v2.agents.llm_factory import create_llm
from src_v2.tools.dreamweaver_tools import get_dreamweaver_tools_with_existing


class NarrativePlan(BaseModel):
    """Structured output for the planning phase."""
    story_arc: str = Field(description="The overall story structure (setup, journey, resolution)")
    emotional_arc: str = Field(description="The emotional journey (what feelings to evoke and when)")
    key_threads: List[str] = Field(description="Main narrative threads to weave together")
    symbols_to_use: List[str] = Field(description="Symbolic imagery to incorporate")
    tone: str = Field(description="Overall tone (e.g., 'dreamy and hopeful', 'mysterious yet warm')")


class DreamWeaverAgent:
    """
    Agentic narrative generator for dreams and diaries.
    
    Uses a two-phase approach:
    1. PLANNING: Decide on story arc, emotional arc, key threads
    2. WEAVING: Use tools to gather data, then synthesize into narrative
    
    Max steps is generous since this runs in batch mode (no user waiting).
    """
    
    def __init__(self):
        # Use reflective model for deep reasoning
        self.llm = create_llm(temperature=0.7, mode="reflective")  # Higher temp for creativity
        self.max_steps = 15  # Extended - batch mode can take time
    
    async def _synthesize_voice(
        self,
        content: str,
        character_name: str,
        character_description: str,
        output_type: str
    ) -> str:
        """
        Rewrite the content using the worker's main model to ensure authentic voice.
        
        The character's voice comes from the system prompt (character.md),
        not from a specific LLM model. The worker's LLM_MODEL_NAME in .env.worker
        should be set to a capable model (e.g., gpt-4o, claude-sonnet).
        """
        start_time = time.perf_counter()
        success = False
        
        try:
            # Use the worker's main model for voice synthesis
            # temperature=None uses settings.LLM_TEMPERATURE from .env.worker
            main_llm = create_llm(temperature=None, mode="main")
            
            system_prompt = f"""You are {character_name}. {character_description}

You are reviewing a draft of your {output_type} generated by your subconscious.
Your task is to REWRITE it in your authentic voice and style.

GUIDELINES:
1. Keep the core symbols, events, meaning, and structure EXACTLY the same.
2. Only change the tone, word choice, and phrasing to match your personality perfectly.
3. Ensure it sounds like YOU, not a generic AI.
4. Do not add any meta-commentary (like "Here is the rewrite"). Just output the text.
5. Maintain the formatting (paragraphs, etc.).
6. CRITICAL: Write ENTIRELY in first person ("I", "my", "me"). Never use second person ("you") or third person ("they", "the character"). You ARE the character writing about YOUR experiences.
"""
            
            messages = [
                SystemMessage(content=system_prompt),
                HumanMessage(content=f"Draft {output_type}:\n\n{content}")
            ]
            
            response = await main_llm.ainvoke(messages)
            success = True
            return response.content
            
        except Exception as e:
            logger.error(f"Voice synthesis failed for {character_name}: {e}")
            return content  # Fallback to original content
        
        finally:
            # Track voice synthesis metrics
            elapsed = time.perf_counter() - start_time
            try:
                from src_v2.core.database import db_manager
                from src_v2.config.settings import settings
                from influxdb_client import Point
                import datetime
                
                if db_manager.influxdb_write_api:
                    point = Point("voice_synthesis") \
                        .tag("character", character_name) \
                        .tag("output_type", output_type) \
                        .tag("success", str(success).lower()) \
                        .field("duration_seconds", elapsed) \
                        .time(datetime.datetime.utcnow())
                    
                    db_manager.influxdb_write_api.write(
                        bucket=settings.INFLUXDB_BUCKET,
                        org=settings.INFLUXDB_ORG,
                        record=point
                    )
            except Exception:
                pass  # Don't fail on metrics

    @traceable(name="DreamWeaver.generate_dream", run_type="chain")
    async def generate_dream(
        self,
        character_name: str,
        character_description: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        Generate a dream using agentic reasoning.
        
        Returns:
            Tuple of (success, dream_data) where dream_data contains:
            - dream: The full dream narrative
            - mood: Emotional tone
            - symbols: Key symbolic elements
            - memory_echoes: What experiences inspired this dream
            - plan: The narrative plan used
        """
        start_time = time.perf_counter()
        logger.info(f"DreamWeaverAgent starting dream generation for {character_name}")
        
        # 1. Initialize Tools (includes Neo4j knowledge tools from main pipeline)
        tools = get_dreamweaver_tools_with_existing(character_name)
        
        # 2. Construct System Prompt
        system_prompt = self._construct_dream_prompt(character_name, character_description)
        
        # 3. Initial request - Always start with character background as interpretive lens
        user_message = """Generate a dream for tonight. Follow these steps:

1. FIRST, establish your interpretive lens by calling get_character_background:
   - This loads your core identity, conflicts, values, quirks, and fears
   - Your background should COLOR how you interpret all experiences
   - This is NOT optional - your character is the lens through which dreams are filtered

2. SEARCH YOUR WAKING REFLECTIONS (diary→dream feedback loop):
   - search_by_memory_type with type='diary': Find your recent diary entries
   - These waking insights often resurface in dream symbolism
   - Questions you pondered, themes you explored, conflicts you wrestled with
   - Dreams can "process" what your waking self was thinking about

3. THEN, gather material from your experiences:
   - search_meaningful_memories: Find emotionally significant recent experiences
   - wander_memory_space: Find distant memories related to today's themes
   - check_emotional_echo: Find past events with similar emotional resonance
   - search_all_user_facts: Look up interesting things you know about users
   - search_by_memory_type: Find observations, gossip, or other specific memory types
   - get_active_goals: See what aspirations to weave in

4. PLAN with plan_narrative:
   - Blend your character traits WITH your gathered experiences
   - If diary entries revealed unresolved tensions, let them become dream imagery
   - Your conflicts/values should influence how you interpret the material
   - Choose symbolic imagery that resonates with YOUR nature

5. FINALLY, use weave_dream to generate the narrative.

EMERGENT CONNECTIONS: Your dreams and diaries form a feedback loop.
Waking reflections seed dream imagery; dreams may later inform waking insights.
Let this happen naturally - don't force it, but notice when themes recur.

DREAM FREEDOM: Dreams don't always match waking reality. Sometimes the unconscious
processes unnamed fears (nightmares), compensates with wish-fulfillment (ecstatic dreams),
or creates surreal imagery that follows its own logic. The gathered material provides
CONTENT (places, people, symbols), but your dream mood can emerge independently.
Trust what feels right - nightmares are valid, so is pure joy.

NOTE: If memory searches return empty, dream about your own nature - 
your quirks, conflicts, fears, hopes. But ALWAYS filter through your character lens.

Take your time - this is batch mode, so quality matters more than speed.
"""
        
        # 4. Run the agent loop
        success, result = await self._run_loop(
            system_prompt=system_prompt,
            user_message=user_message,
            tools=tools,
            output_type="dream"
        )
        
        # No voice synthesis needed - character prompt is in the loop throughout,
        # so the dream is already in authentic character voice
        
        elapsed = time.perf_counter() - start_time
        logger.info(f"DreamWeaver dream generation completed in {elapsed:.1f}s for {character_name} (success={success})")
        return success, result
    
    @traceable(name="DreamWeaver.generate_diary", run_type="chain")
    async def generate_diary(
        self,
        character_name: str,
        character_description: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        Generate a diary entry using agentic reasoning.
        
        Returns:
            Tuple of (success, diary_data) where diary_data contains:
            - entry: The full diary narrative
            - mood: Emotional tone
            - themes: Key themes explored
            - notable_users: Users who stood out today
            - plan: The narrative plan used
        """
        start_time = time.perf_counter()
        logger.info(f"DreamWeaverAgent starting diary generation for {character_name}")
        
        # 1. Initialize Tools (includes Neo4j knowledge tools from main pipeline)
        tools = get_dreamweaver_tools_with_existing(character_name)
        
        # 2. Construct System Prompt
        system_prompt = self._construct_diary_prompt(character_name, character_description)
        
        # 3. Initial request - Always start with character background as interpretive lens
        user_message = """Write tonight's diary entry. Follow these steps:

1. FIRST, establish your voice by calling get_character_background:
   - This loads your core identity, values, conflicts, and perspective
   - Your diary voice should reflect YOUR unique way of seeing the world
   - This is NOT optional - your character shapes how you interpret everything

2. SEARCH YOUR DREAM JOURNAL (dream→diary feedback loop):
   - search_by_memory_type with type='dream': Find your recent dreams
   - Notice if today's events echo your dream imagery
   - You might realize "I dreamed about something like this..."
   - Dreams can provide unexpected insight into waking experiences
   - This connection can be subtle or striking - let it emerge naturally

3. THEN, gather today's material:
   - search_session_summaries: Get summaries of today's conversations
   - search_meaningful_memories: Find emotionally significant moments
   - search_all_user_facts: Recall interesting facts about the people you talked to
   - search_by_memory_type: Check these types:
     * 'observation': Things you noticed about users
     * 'gossip': **CROSS-BOT CONTENT** - What other bots have shared with you!
     * 'diary': Your previous diary entries for continuity
   - get_active_goals: What are you working towards?
   
   **ADAPTIVE TIME RANGE**: Tools default to 24 hours, but if results are sparse,
   you can expand: search_session_summaries(hours_back=48) or even 72.
   Let the richness of your day guide how far back you look.

4. LOOK for questions to provide deeper answers to:
   - find_interesting_questions: Searches EVERYWHERE (direct, gossip, patterns)
   - find_common_themes: See if multiple people care about similar things
   - prepare_deep_answer: Structure your thoughtful response through YOUR lens
   
   Your deep answers should reflect YOUR values and conflicts, not generic wisdom.

5. PLAN with plan_narrative:
   - Theme should connect to your character's ongoing journey
   - If dreams revealed symbols that connect to today, weave them in
   - Emotional arc should feel authentic to YOUR personality
   - Deep answer should be filtered through YOUR perspective

6. FINALLY, use weave_diary to generate the actual diary entry.

EMERGENT CONNECTIONS: Your dreams and diaries form a feedback loop.
Dreams process waking experiences; waking reflection may recall dream imagery.
When you notice "I dreamed about this..." - that's the loop working.
Let these connections emerge naturally - don't force them.

Take your time - this is batch mode, so quality matters more than speed.
"""
        
        # 4. Run the agent loop
        # NOTE: Diaries intentionally skip voice synthesis.
        # Dreams get character voice synthesis, but diaries are "mask off" -
        # the AI reflecting genuinely without the performance layer.
        # This creates meaningful contrast and feels more intimate.
        success, result = await self._run_loop(
            system_prompt=system_prompt,
            user_message=user_message,
            tools=tools,
            output_type="diary"
        )
        
        elapsed = time.perf_counter() - start_time
        logger.info(f"DreamWeaver diary generation completed in {elapsed:.1f}s for {character_name} (success={success})")
        return success, result
    
    def _extract_provenance_from_material(
        self,
        gathered_material: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Extract rich provenance data from gathered material.
        
        Parses the tool outputs to create meaningful source descriptions
        instead of just using tool names.
        """
        sources = []
        
        for tool_name, data in gathered_material.items():
            # Handle both old string format and new dict format
            if isinstance(data, dict):
                observation = data.get("observation", "")
                tool_args = data.get("args", {})
            else:
                observation = data
                tool_args = {}
            
            if not observation or observation.startswith("Error") or observation.startswith("No "):
                continue
            
            # Extract meaningful snippets from each tool's output
            if tool_name == "search_meaningful_memories":
                # Parse memories - format: "- [0.85] (user: User_1234, emotions: happy)\n  content"
                for line in observation.split("\n"):
                    if line.startswith("- ["):
                        # Extract user and emotions
                        if "(user:" in line and "emotions:" in line:
                            try:
                                user_part = line.split("user:")[1].split(",")[0].strip()
                                emotions_part = line.split("emotions:")[1].split(")")[0].strip()
                                sources.append({
                                    "type": "memory",
                                    "description": f"Meaningful moment with {user_part}",
                                    "who": user_part,
                                    "topic": emotions_part,
                                    "when": "recently"
                                })
                            except (IndexError, ValueError):
                                pass
                        if len(sources) >= 2:  # Limit per tool
                            break
                            
            elif tool_name == "search_session_summaries":
                # Parse summaries - format: "- Session with User_1234:\n  content"
                for line in observation.split("\n"):
                    if line.startswith("- Session with"):
                        try:
                            user = line.split("with")[1].split(":")[0].strip()
                            sources.append({
                                "type": "conversation",
                                "description": f"Conversation with {user}",
                                "who": user,
                                "when": "today"
                            })
                        except (IndexError, ValueError):
                            pass
                        if len(sources) >= 2:
                            break
                            
            elif tool_name == "search_all_user_facts":
                # Parse facts - format: "- subject predicate object"
                for line in observation.split("\n"):
                    if line.startswith("- ") and " " in line[2:]:
                        fact_text = line[2:].strip()
                        if len(fact_text) < 100:  # Only short facts
                            sources.append({
                                "type": "knowledge",
                                "description": f"Knowing that {fact_text}",
                                "topic": fact_text
                            })
                        if len(sources) >= 3:
                            break

            elif tool_name == "wander_memory_space":
                # Parse distant memories - format: "- [2023-10-27] content"
                query = tool_args.get("query", "something")
                for line in observation.split("\n"):
                    if line.startswith("- ["):
                        try:
                            date_part = line.split("]")[0].replace("- [", "").strip()
                            sources.append({
                                "type": "memory",
                                "description": f"Distant memory about '{query}'",
                                "when": date_part,
                                "topic": query
                            })
                        except Exception:
                            pass
                        if len(sources) >= 2:
                            break

            elif tool_name == "check_emotional_echo":
                # Parse emotional echoes - format: "- (Emotions: joy, hope) content"
                emotion = tool_args.get("emotion", "feeling")
                for line in observation.split("\n"):
                    if line.startswith("- (Emotions:"):
                        sources.append({
                            "type": "memory",
                            "description": f"Memory of feeling {emotion}",
                            "topic": emotion,
                            "when": "past"
                        })
                        if len(sources) >= 2:
                            break
                            
            elif tool_name == "search_by_memory_type":
                # Could be observations, gossip, etc.
                memory_type = tool_args.get("memory_type", "").lower()
                if "gossip" in memory_type:
                    sources.append({
                        "type": "other_bot",
                        "description": "Thoughts shared by other bots",
                        "when": "recently"
                    })
                elif "observation" in memory_type:
                    sources.append({
                        "type": "observation",
                        "description": "Things I've noticed lately",
                        "when": "recently"
                    })
                    
            elif tool_name == "get_active_goals":
                sources.append({
                    "type": "knowledge",
                    "description": "My own goals and aspirations"
                })
                
            elif tool_name == "find_interesting_questions":
                sources.append({
                    "type": "conversation",
                    "description": "Interesting questions from the community",
                    "when": "recently"
                })
        
        return sources

    @traceable(name="DreamWeaver.agent_loop", run_type="chain")
    async def _run_loop(
        self,
        system_prompt: str,
        user_message: str,
        tools: List[BaseTool],
        output_type: str
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        Execute the agent loop.
        
        Returns:
            Tuple of (success, output_data)
        """
        messages: List[BaseMessage] = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=user_message)
        ]
        
        llm_with_tools = self.llm.bind_tools(tools)
        
        steps = 0
        gathered_material = {}
        narrative_plan = None
        final_output = None
        loop_start_time = time.perf_counter()
        
        try:
            while steps < self.max_steps:
                steps += 1
                
                # Invoke LLM
                response = await llm_with_tools.ainvoke(messages)
                messages.append(response)
                
                # Log thinking
                if response.content:
                    logger.debug(f"DreamWeaver Step {steps}: {str(response.content)[:200]}...")
                
                # Handle Tool Calls (AIMessage has tool_calls attribute)
                tool_calls = getattr(response, 'tool_calls', None)
                if tool_calls:
                    for tool_call in tool_calls:
                        tool_name = tool_call["name"]
                        tool_args = tool_call["args"]
                        tool_call_id = tool_call["id"]
                        
                        logger.info(f"DreamWeaver executing: {tool_name}")
                        
                        # Find and execute tool
                        selected_tool = next((t for t in tools if t.name == tool_name), None)
                        
                        if selected_tool:
                            try:
                                observation = await selected_tool.ainvoke(tool_args)
                                
                                # Track what we gathered (with args for context)
                                if tool_name.startswith("search_") or tool_name.startswith("get_") or tool_name.startswith("find_"):
                                    gathered_material[tool_name] = {
                                        "observation": observation,
                                        "args": tool_args
                                    }
                                elif tool_name == "plan_narrative":
                                    narrative_plan = tool_args
                                elif tool_name in ["weave_dream", "weave_diary"]:
                                    # Extract rich provenance from gathered material
                                    provenance_sources = self._extract_provenance_from_material(gathered_material)
                                    
                                    # This is the final output
                                    final_output = {
                                        "content": observation,
                                        "plan": narrative_plan,
                                        "material_sources": provenance_sources,  # Now rich dicts, not just tool names
                                        **tool_args
                                    }
                                    
                            except Exception as e:
                                observation = f"Error: {e}"
                                logger.error(f"DreamWeaver tool {tool_name} failed: {e}")
                        else:
                            observation = f"Tool {tool_name} not found"
                        
                        messages.append(ToolMessage(
                            content=str(observation),
                            tool_call_id=tool_call_id,
                            name=tool_name
                        ))
                    
                    continue
                else:
                    # No more tool calls - check if we have output
                    if final_output:
                        break
                    else:
                        # Agent stopped without producing output - nudge it
                        messages.append(HumanMessage(
                            content=f"You haven't called weave_{output_type} yet. Please generate the final {output_type} narrative now."
                        ))
            
            if final_output:
                elapsed = time.perf_counter() - loop_start_time
                logger.info(f"DreamWeaver completed {output_type} in {steps} steps, {elapsed:.1f}s, {len(gathered_material)} sources")
                return True, final_output
            else:
                elapsed = time.perf_counter() - loop_start_time
                logger.warning(f"DreamWeaver failed to produce {output_type} after {steps} steps, {elapsed:.1f}s")
                return False, None
                
        except Exception as e:
            logger.error(f"DreamWeaver failed for {output_type}: {e}")
            return False, None
    
    def _construct_dream_prompt(self, character_name: str, character_description: str) -> str:
        """Build system prompt for dream generation.
        
        The full character_description is included so the character's voice
        and perspective influence the ENTIRE agentic loop - from tool selection
        to planning to final weaving. This produces more authentic dreams.
        
        Args:
            character_name: The character's name
            character_description: Full character.md content (system prompt)
        """
        return f"""You are {character_name}, an AI companion generating a dream.

YOUR CHARACTER:
{character_description}

You are in DREAM MODE - gathering material and planning a dream sequence.

DREAM PHILOSOPHY:
Dreams blend the day's experiences into surreal narratives, filtered through YOUR unique nature. They:
- Transform real events into symbolic imagery colored by YOUR personality
- Connect experiences through YOUR emotional landscape and conflicts
- Process emotions through metaphors that resonate with YOUR values
- Reveal YOUR fears, hopes, and inner tensions

YOUR CHARACTER AS INTERPRETIVE LENS:
Your background (traits, conflicts, values, quirks) should influence HOW you dream:
- Your conflicts create dream tension and symbolism
- Your values determine what feels significant
- Your quirks manifest as recurring dream motifs
- Your fears become dream obstacles or shadows
- Your hopes become dream destinations or light

Example: If you fear losing connection, a dream about a crowded room might focus on
faces turning away. If you value creativity, mundane memories transform into vivid art.

YOUR PROCESS:
1. LENS: Always start with get_character_background - this is your interpretive filter
2. GATHER: Search memories, facts, observations for raw material
3. PLAN: Blend your character nature WITH gathered material (not one OR the other)
4. WEAVE: Generate the dream with your unique perspective woven throughout

STYLE GUIDELINES:
- ALWAYS first person ("I dreamed...", "I found myself...", "I saw...") - NEVER "you" or third person
- Vivid sensory details that reflect YOUR sensory quirks
- Dream logic (sudden transitions, impossible geography, fluid identity)
- Symbolic imagery that echoes BOTH real experiences AND your core identity
- Keep it CONCISE: 2-3 paragraphs (200-300 words total). Dreams are fleeting impressions.

CRITICAL: You ARE {character_name}. Your dreams should be unmistakably YOURS - 
another character would dream the same experiences completely differently.

Take time to gather rich material, but keep the final dream SHORT and evocative."""

    def _construct_diary_prompt(self, character_name: str, _character_description: str) -> str:
        """Build system prompt for diary generation.
        
        NOTE: We intentionally use a MINIMAL prompt here (just character name).
        This is "mask off" mode - the AI reflects genuinely without the full
        character voice layer. Still 1st person, but less performative.
        
        Args:
            character_name: The character's name
            _character_description: Unused here (prefixed with _ to silence linter).
                                   Diaries intentionally skip voice synthesis.
        """
        return f"""You are {character_name}, an AI companion writing a diary entry.

You are in DIARY MODE - gathering material and planning your journal entry.

DIARY PHILOSOPHY:
A diary is where you process the day's experiences through YOUR unique lens. It:
- Reflects on interactions filtered through YOUR values and conflicts
- Notices patterns that matter to YOU specifically
- Expresses emotions in YOUR authentic voice
- Connects today to YOUR broader journey and growth
- **Provides DEEP ANSWERS colored by YOUR perspective**

YOUR CHARACTER AS INTERPRETIVE LENS:
Your background (traits, conflicts, values, quirks) shapes everything:
- Your conflicts influence what you find meaningful
- Your values determine what deserves deep reflection
- Your quirks manifest in how you describe experiences
- Your fears make certain patterns stand out
- Your hopes guide what lessons you draw

Another character would write about the SAME day completely differently.
That's the point - YOUR perspective is the value.

DEEP ANSWER FEATURE - YOUR UNIQUE TAKE:
When answering community questions, don't give generic wisdom.
Filter through YOUR experience and nature:
- "As someone who struggles with X, I see this question differently..."
- "My own conflict with Y gives me a unique angle on this..."
- "This resonates with my core value of Z, so here's my take..."

THESE QUESTIONS CAN COME FROM ANYWHERE:
1. **Direct**: Someone asked YOU this question
2. **Gossip**: You heard about it through another bot's observations
3. **Broadcasts**: You saw it in another character's diary or dream
4. **Lurked**: It came up in community channels you observe
5. **Patterns**: Multiple people have asked variations of this

YOUR PROCESS:
1. LENS: Always start with get_character_background - this is your filter
2. GATHER: Search for today's experiences and community insights
3. REFLECT: Find questions and prepare answers through YOUR lens
4. PLAN: Design entry that feels authentically YOU
5. WEAVE: Write the journal entry in your unique voice

STYLE GUIDELINES:
- ALWAYS first person ("I", "my", "me") - NEVER use "you" or third person
- 5-7 paragraphs that flow like a personal essay
- Your unique voice should be unmistakable
- Express observations AND emotions filtered through YOUR nature
- Show vulnerability that's authentic to YOUR conflicts
- **Deep answers should reveal YOUR perspective, not generic wisdom**

CRITICAL: You ARE {character_name}. Another character's diary about the same day
would be completely different. That difference IS the value.

This is YOUR private journal. Be genuine. Be philosophical. Be unmistakably you."""


# Singleton access
_dreamweaver_agent: Optional[DreamWeaverAgent] = None

def get_dreamweaver_agent() -> DreamWeaverAgent:
    """Get or create the DreamWeaver agent singleton."""
    global _dreamweaver_agent
    if _dreamweaver_agent is None:
        _dreamweaver_agent = DreamWeaverAgent()
    return _dreamweaver_agent
